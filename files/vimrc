"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" my dot.vimrc config (don't try this at home!) Nicola
"

" vundle  {

    set nocompatible              " be iMproved, required
    filetype off                  " required

    " set the runtime path to include Vundle and initialize
    
    set rtp+=~/.vim/bundle/Vundle.vim
    call vundle#begin()

    Plugin 'gmarik/Vundle.vim'

    Plugin 'maxbrunsfeld/vim-yankstack'    
     
    Plugin 'terryma/vim-multiple-cursors.git'

    Plugin 'scrooloose/syntastic'
    Plugin 'majutsushi/tagbar'
    Plugin 'vim-airline/vim-airline'
    Plugin 'vim-airline/vim-airline-themes'
    Plugin 'kien/ctrlp.vim'
    Plugin 'sjl/gundo.vim'
    
    Plugin 'airblade/vim-gitgutter'

    Plugin 'henrik/vim-indexed-search'
    Plugin 'bkad/CamelCaseMotion.git'

    Plugin 'tpope/vim-fugitive'
    Plugin 'tpope/vim-abolish'
    Plugin 'tpope/vim-commentary'
    Plugin 'tpope/vim-dispatch'
    Plugin 'tpope/vim-surround'

    Plugin 'Shougo/vimproc.vim'
    " Plugin 'Shougo/neocomplete.vim'
    
    Plugin 'triglav/vim-visual-increment'
    Plugin 'nathanaelkane/vim-indent-guides'
    Plugin 'henrik/vim-qargs'

    " Haskell
    
    Plugin 'bitc/vim-hdevtools'
    Plugin 'eagletmt/neco-ghc'
    "Plugin 'eagletmt/ghcmod-vim' -> replaced by hdevtools 

    " Idris
    Plugin 'idris-hackers/idris-vim'

    call vundle#end()            " required

" }


" general {

        syntax enable

        filetype on
        filetype plugin on
        filetype indent on
    
        set shell=bash
        set nocompatible        	

        "set rtp+=~/.vim/bundle/powerline/powerline/bindings/vim

        set backspace=indent,eol,start 
        
        set completeopt=menu,longest
        set complete=.,w,b,t,i

        " set term=screen-256color
        
        set shortmess+=at
 
        set nofoldenable
        set novisualbell                
        set noerrorbells
        set hidden
        set lazyredraw

        set wrapscan
        set ch=2
        set synmaxcol=1024
        set cpoptions+=$

        set expandtab

        set foldlevel=0
        set autowrite

        set hlsearch
        set incsearch

        set showcmd
        set showmode
        set showfulltag

        set wildmenu
        set pastetoggle=<F12>

        set history=1000
        set undolevels=1000


        set ruler
        set magic
        set mps+=<:> " this is great for C++ template meta-programming
        
        set wildignore+=*/.git/*,*/.hg/*,*/.svn/* " Linux/MacOSX
        set wildignore+=*.o,*.so,*.ko,*.bak
        
        set nowrap
        set guioptions=acm

        set foldmethod=syntax
        set virtualedit=all

        set stl=%f\ %m\ %r\ Line:\ %l/%L[%p%%]\ Col:\ %c\ Buf:\ #%n\ [%b][0x%B]

        set laststatus=2
        
        set updatetime=2750
        
        set clipboard=unnamed
        set viminfo='10,<10000,:100,%,s1000,n~/.viminfo

        set spell

        set grepprg=cgrep

        " set ignorecase 
        " set smartcase  
        " set infercase

        set path+=/usr/include
        set path+=/usr/include/c++/4.9

        " default tab and stuff
        "
        set shiftwidth=4 
        set tabstop=4 
        set autoindent 
        set copyindent
        set smartindent 
        set smarttab

        " set t_Co=256

        set timeoutlen=1000 ttimeoutlen=50

        let g:airline_theme='molokai'

        if has("gui_running")
                set guifont=Terminus\ 10
                " colorscheme github
                colorscheme default
        else
                " colorscheme github
                colorscheme default
        endif

        set diffopt=filler,iwhite,context:10
" }
 

" plugin config {

        """ my C/++ ctags options...
        
        let g:my_ctags_options = [ '--sort=foldcase', '--languages=C,C++', '--c++-kinds=+plx', '--fields=+liaS', '--extra=+q', '-I __attribute__+' ]

        """ this to avoid spurious highlight with C++11 lambdas 
        
        let c_no_curly_error = 1


        """ tagbar
        
        let g:tagbar_width = 30
        
        """ clang completion...
        
        let g:clang_complete_auto   = 0
        let g:clang_complete_copen  = 1
        let g:clang_user_options    = '-std=c++1y'

        """ ctrl+p
        
        let g:ctrlp_map = ''
        let g:ctrlp_dotfiles = 0

        """ powerline
        
        set encoding=utf-8
        let g:Powerline_symbols = 'fancy'
       
        runtime! ftplugin/man.vim
        runtime! ftplugin/gzip.vim
        runtime! ftplugin/taglist.vim 

        """ syntastic: C++/Haskell
        
        let g:syntastic_cpp_compiler = 'clang++'
        let g:syntastic_cpp_compiler_options = ' -std=c++1y -stdlib=libc++'
        let g:syntastic_haskell_hdevtools_args = '-g-isrc -g-Wall -g-cpp'

        """ git-gutter
    
        let g:gitgutter_sign_column_always = 0
        let g:gitgutter_realtime = 1
        let g:gitgutter_eager = 1

        """ vim-multiple-cursor

        let g:multi_cursor_next_key='<C-n>'
        let g:multi_cursor_prev_key='<C-m>'
        let g:multi_cursor_skip_key='<C-x>'
        let g:multi_cursor_quit_key='<Esc>'

        """ yankstack

        nmap <leader>p <Plug>yankstack_substitute_older_paste
        nmap <leader>P <Plug>yankstack_substitute_newer_paste

        """ misc...

        let Tlist_Use_Right_Window  = 1
        let g:load_doxygen_syntax   = 1
"}


" automatic {

if has("autocmd")

        let g:c_syntax_for_h = 1

        autocmd BufNewFile,BufRead *.c   set filetype=c   
        autocmd BufNewFile,BufRead *.h   set filetype=c   
        autocmd BufNewFile,BufRead *.cpp set filetype=cpp  
        autocmd BufNewFile,BufRead *.hpp set filetype=cpp  
        autocmd BufNewFile,BufRead *.hsc set filetype=haskell

        " save time-consuming foldmethod=syntax while in insert mode... 
        
        autocmd InsertEnter * if !exists('w:last_fdm') | let w:last_fdm=&foldmethod | setlocal foldmethod=manual | endif
        autocmd InsertLeave,WinLeave * if exists('w:last_fdm') | let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif

        " disable syntax on very huge files...
        
        autocmd BufReadPre *  if getfsize(expand('<afile>')) > 1000000 | syntax off | endif
        autocmd BufEnter * set tags=~/.vim/system-tags,./tags,../tags,tags,TAGS

        autocmd QuickFixCmdPost [^l]* nested cwindow
        autocmd QuickFixCmdPost    l* nested lwindow

        autocmd FileType text setlocal textwidth=118
        
        " clear trailing white-spaces (currently disabled: see
        " RemoveTrailingSpaces command)
        " 
        " autocmd FileType cpp,c,haskell,make autocmd BufWritePre <buffer> :%s/\s\+$//e

        autocmd FileType make set noexpandtab
        autocmd FileType make set shiftwidth=8
        
        autocmd BufWinEnter * call ResCur()

        autocmd FileType haskell call LangHaskell()
        autocmd FileType cpp     call LangCpp()
        autocmd FileType c       call LangC()
endif

" }

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" functions {

if !exists(":DiffOrig")
        command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
        \ | wincmd p | diffthis
endif

function! ResCur()
        if line("'\"") <= line("$")
                norm! g`"
                return 1
        endif
endfunction

" eat a char

function Eatchar(pat)
        let c = nr2char(getchar(0))
        return (c =~ a:pat) ? '' : c
endfunc

" ctags functions 

function! s:update_ctags()
        exec ":silent !ctags -R " . join(g:my_ctags_options, ' ')    
        exec ":redraw!"
        echohl StatusLine | echo "Ctags updated." 
endfunction

" hasktags functions 

function! s:update_htags ()
        exec ":silent !hasktags -c --ignore-close-implementation ."   
        exec ":redraw!"
        echohl StatusLine | echo "Hasktags updated." 
endfunction
         

command! UpdateCTags call s:update_ctags()
command! UpdateHaskTags call s:update_htags()

" http://vim.wikia.com/wiki/Toggle_to_open_or_close_the_quickfix_window
" toggles the quickfix window.

function! QFixToggle(forced)
  if exists("g:qfix_win") && a:forced == 0
    cclose
  else
    copen
  endif
endfunction


function! QuickFixFilenames()
    let buffer_numbers = {}
    for item in getqflist()
        let buffer_numbers[item['bufnr']] = bufname(item['bufnr'])
    endfor
    return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction


function! SearchWithSkip(pattern, flags, stopline, timeout, skip)
"
" Returns true if a match is found for {pattern}, but ignores matches
" where {skip} evaluates to false. This allows you to do nifty things
" like, say, only matching outside comments, only on odd-numbered lines,
" or whatever else you like.
"
" Mimics the built-in search() function, but adds a {skip} expression
" like that available in searchpair() and searchpairpos().
" (See the Vim help on search() for details of the other parameters.)
" 
    " Note the current position, so that if there are no unskipped
    " matches, the cursor can be restored to this location.
    "
    let l:matchpos = getpos('.')

    " Loop as long as {pattern} continues to be found.
    "
    while search(a:pattern, a:flags, a:stopline, a:timeout) > 0

        " If {skip} is true, ignore this match and continue searching.
        "
        if eval(a:skip)
            continue
        endif

        " If we get here, {pattern} was found and {skip} is false,
        " so this is a match we don't want to ignore. Update the
        " match position and stop searching.
        " 
        let l:matchpos = getpos('.')
        break

    endwhile

    " Jump to the position of the unskipped match, or to the original
    " position if there wasn't one.
    "
    call setpos('.', l:matchpos)

endfunction


function! SearchOutside(synName, pattern)
"
" Searches for the specified pattern, but skips matches that
" exist within the specified syntax region.
"
    call SearchWithSkip(a:pattern, '', '', '',
        \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "' . a:synName . '"' )

endfunction


function! SearchInside(synName, pattern)
"
" Searches for the specified pattern, but skips matches that don't
" exist within the specified syntax region.
"
    call SearchWithSkip(a:pattern, '', '', '',
        \ 'synIDattr(synID(line("."), col("."), 0), "name") !~? "' . a:synName . '"' )

endfunction



" }

" command {
 
    command! -nargs=+ -complete=command SearchOutside call SearchOutside(<f-args>)
    command! -nargs=+ -complete=command SearchInside  call SearchInside(<f-args>)

    command! -nargs=* -complete=shellcmd R new | setlocal buftype=nofile bufhidden=hide noswapfile | R !<args>
    command! -bang -nargs=? QFix call QFixToggle(<bang>0)
    command! -nargs=0 -bar Qargs execute 'args' QuickFixFilenames()

    command! -bang -nargs=0 RemoveTrailingSpaces :%s/\s\+$//e

    " used to track the quickfix window

    augroup QFixToggle
        autocmd!
        autocmd BufWinEnter quickfix let g:qfix_win = bufnr("$")
        autocmd BufWinLeave * if exists("g:qfix_win") && expand("<abuf>") == g:qfix_win | unlet! g:qfix_win | endif
    augroup END
" }


" language_options {

function LangC()

        setlocal tabstop=8
        setlocal shiftwidth=8
        setlocal softtabstop=8
        setlocal textwidth=120
        setlocal noexpandtab

        setlocal cindent
        setlocal formatoptions=tcqlron
        setlocal cinoptions=:0,l1,t0,g0,(0

        cmap ;tf ?^{??(?,/^}/

        setlocal iskeyword=a-z,A-Z,48-57,_,'
        setlocal noexpandtab
        
        syn keyword cOperator likely unlikely 
        syn keyword cType u8 u16 u32 u64 s8 s16 s32 s64

        highlight default link LinuxError ErrorMsg

        syn match LinuxError / \+\ze\t/     " spaces before tab
        syn match LinuxError /\s\+$/        " trailing whitespaces
        "syn match LinuxError /\%121v.\+/    " virtual column 121 and more

        iab intmain int<CR>main(int argc, char *argv[])<CR>{<CR>return 0;<CR>}<CR><UP><UP><RIGHT>
        iab #i #include <><Left><C-R>=Eatchar('\s')<CR>
        iab #I #include ""<Left><C-R>=Eatchar('\s')<CR>
        iab #d #define 
        iab #p #pragma once

        iab __P __PRETTY_FUNCTION__
        iab __F __FUNCTION__

        nnoremap <F2>    :AssGen<CR>
        nnoremap <F4>    :UpdateCTags<CR>
        nnoremap <F7>    :Make<CR>
        nnoremap <F11>   :AssClangRun<CR>
        nnoremap <S-F11> :AssGccRun<CR>
        nnoremap <S-F10> :AssIncludeThis<CR>
        
endfunction

function LangCpp()
        
        cmap ;tf ?^{??(?,/^}/
        map <C-]> :exe "tj " . expand("<cword>") <CR>

        setlocal cinoptions={0}0:0=4l1g0p0t0i0+0(0u2W4
        setlocal shiftwidth=4 
        setlocal tabstop=4 
        setlocal iskeyword=a-z,A-Z,48-57,_,'
        setlocal cms=//%s

        " abbreviations...
        "
        iab intmain int<CR>main(int argc, char *argv[])<CR>{<CR>return 0;<CR>}<CR><UP><UP><RIGHT>
        iab #i #include <><Left><C-R>=Eatchar('\s')<CR>
        iab #I #include ""<Left><C-R>=Eatchar('\s')<CR>
        iab #d #define 
        iab #p #pragma once

        iab ns namespace<C-R>=Eatchar('\s')<CR>
        iab co std::cout<C-R>=Eatchar('\s')<CR>
        iab ce std::cerr<C-R>=Eatchar('\s')<CR>
        iab el std::endl<C-R>=Eatchar('\s')<CR>

        iab dv declval<Left><C-R>=Eatchar('\s')<CR>
        iab dt decltype()<Left><C-R>=Eatchar('\s')<CR>
        iab tn typename
        iab td typedef
        "iab tp template <><Left><C-R>=Eatchar('\s')<CR>

        iab .\ []() {}<Left><Left><Left><Left><Left><Left><C-R>=Eatchar('\s')<CR>

        iab __P __PRETTY_FUNCTION__
        iab __F __FUNCTION__

        " C++ ass'instant: -> github.com/awgn/ass 
        
        nnoremap <F2>    :AssGen<CR>
        nnoremap <F4>    :UpdateCTags<CR>
        nnoremap <F7>    :Make<CR>
        nnoremap <F11>   :AssClangRun<CR>
        nnoremap <S-F11> :AssGccRun<CR>
        nnoremap <S-F10> :AssIncludeThis<CR>
        
        " find the string in non-comment lines (C/C++)
        
        nnoremap <leader>f :/\v((\/\*\|\/\/\|^\s*\*[^/]).*)@<!
 
endfunction

function LangHaskell()
         
         set makeprg=runhaskell\ Setup.hs\ build\ --ghc-options="-W"
 
         setlocal tabstop=4 
         setlocal softtabstop=4 
         setlocal shiftwidth=2 
         setlocal expandtab
 
         setlocal iskeyword=a-z,A-Z,48-57,_,'
         setlocal omnifunc=necoghc#omnifunc
         
         " abbreviations...
         "
        
         iab GHC 
                    \<CR>{-# LANGUAGE ExistentialQuantification  #-}
                    \<CR>{-# LANGUAGE MultiParamTypeClasses      #-}
                    \<CR>{-# LANGUAGE FunctionalDependencies     #-}
                    \<CR>{-# LANGUAGE RankNTypes                 #-}
                    \<CR>{-# LANGUAGE FlexibleInstances          #-}
                    \<CR>{-# LANGUAGE FlexibleContexts           #-}
                    \<CR>{-# LANGUAGE TypeSynonymInstances       #-}
                    \<CR>{-# LANGUAGE ScopedTypeVariables        #-}
                    \<CR>{-# LANGUAGE ViewPatterns               #-}
                    \<CR>{-# LANGUAGE DisambiguateRecordFields   #-}
                    \<CR>{-# LANGUAGE NamedFieldPuns             #-}
                    \<CR>{-# LANGUAGE TupleSections              #-}
                    \<CR>{-# LANGUAGE BangPatterns               #-}
                    \<CR>{-# LANGUAGE OverloadedStrings          #-}
                    \<CR>{-# LANGUAGE OverloadedLists            #-}
                    \<CR>{-# LANGUAGE AutoDeriveTypeable         #-}
                    \<CR>{-# LANGUAGE DeriveDataTypeable         #-}
                    \<CR>{-# LANGUAGE DeriveGeneric              #-}
                    \<CR>{-# LANGUAGE DeriveFunctor              #-}
                    \<CR>{-# LANGUAGE DeriveFoldable             #-}
                    \<CR>{-# LANGUAGE DeriveTraversable          #-}
                    \<CR>{-# LANGUAGE GeneralizedNewtypeDeriving #-} 
                    \<CR>{-# LANGUAGE TypeOperators              #-} 
                    \<CR>{-# LANGUAGE TypeFamilies               #-} 
                    \<CR>{-# LANGUAGE GADTs                      #-}
                    \<CR>{-# LANGUAGE CPP                        #-}
 
         " hdevtools...
         "
         nnoremap <buffer> <F1> :HdevtoolsType<CR>
         nnoremap <buffer> <silent> <F2> :HdevtoolsClear<CR>
         nnoremap <buffer> <silent> <F3> :HdevtoolsInfo<CR>
         nnoremap <F4> :call UpdateHaskTags()<CR>
  
         let g:hdevtools_options = '-g-isrc -g-Wall -g-cpp'
 
endfunction

" }

" mapping {
        

        " general keys...
        "
        nnoremap <F5>    :cprev<CR>
        nnoremap <F6>    :cnext<CR>
        nnoremap <F8>    :QFix<CR>
        nnoremap <F9>    :NERDTreeToggle<CR>
        nnoremap <F10>   :GundoToggle<CR>
        nnoremap <F12>   :TagbarToggle<CR>

        " leaders...
        "
        
        " nnoremap / /\v
        " nnoremap ? ?\v
        
        nnoremap <leader>/ /\<\><Left><Left>
        nnoremap <leader>? ?\<\><Left><Left>
        nnoremap <leader>c :/\(\<class\>\\|\<struct\>\)\s*[a-zA-Z_][a-zA-Z0-9_]*.*\_s*{<CR> 
        
        " eliminate ugly \r 
        
        nnoremap <leader>r :%s/\r//g<CR>

        " replace the world under cursor...
        
        nnoremap <leader>s :%s/\<<C-R><C-W>\>/
        
        " search the word under cursor...
       
        nnoremap <leader>g :grep -r -w <C-R><C-W> 
        
        
        " prepare exact replace
        
        nnoremap <leader>S :%s/\<\>/<Left><Left><Left>

        " disable arrows
        
        map <up>    <nop>
        map <down>  <nop>
        map <left>  <nop>
        map <right> <nop>

        " disable annoying lowercase in visual mode.
       
        xmap u <nop>

        " leader d -> delete the current line, leaving the default register
        " untouched

        nnoremap <leader>d "_dd
        
        " D, delete a visual block using non default register
        
        vnoremap D "_d

        " expand,  %% in the relative directory of the current buffer
        
        cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'
 
        " hex editor...
        
        map <Leader>hon  :%!xxd<CR>
        map <Leader>hoff :%!xxd -r<CR>       
"}

