"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" my dot.vimrc config (don't try this at home!) Nicola
"

" vundle  {

    set nocompatible              " be iMproved, required
    filetype off                  " required

    " set the runtime path to include Vundle and initialize
    
    set rtp+=~/.vim/bundle/Vundle.vim
    call vundle#begin()

    Plugin 'gmarik/Vundle.vim'
    Plugin 'Cpp11-Syntax-Support'
    Plugin 'YankRing.vim'
    Plugin 'tpope/vim-fugitive'
    Plugin 'tpope/vim-abolish'
    Plugin 'tpope/vim-commentary'
    Plugin 'tpope/vim-dispatch'
    Plugin 'tpope/vim-surround'
    Plugin 'triglav/vim-visual-increment'
    Plugin 'bling/vim-airline'
    Plugin 'kien/ctrlp.vim'
    Plugin 'sjl/gundo.vim'
    Plugin 'scrooloose/syntastic'
    Plugin 'majutsushi/tagbar'
    Plugin 'Shougo/vimproc.vim'
    Plugin 'nathanaelkane/vim-indent-guides'

    " Haskell
    Plugin 'bitc/vim-hdevtools'
    Plugin 'eagletmt/neco-ghc'
    Plugin 'bkad/CamelCaseMotion.git'

    " All of your Plugins must be added before the following line
    
    call vundle#end()            " required

" }

" general {

        syntax enable

        filetype on
        filetype plugin on
        filetype indent on
       
        set nocompatible        	

        set rtp+=~/.vim/bundle/powerline/powerline/bindings/vim

        set backspace=indent,eol,start 
        
        set completeopt=menu,longest
        set complete=.,w,b,t,i

        set term=screen-256color
        
        set shortmess+=at
 
        set nofoldenable
        set novisualbell                
        set hidden
        set lazyredraw

        set wrapscan
        set ch=2
        set synmaxcol=1024
        set cpoptions+=$

        set expandtab

        set foldlevel=0
        set autowrite

        set hlsearch
        set incsearch

        set showcmd
        set showmode
        set showfulltag

        set wildmenu
        set pastetoggle=<F12>

        set history=1000
        set undolevels=1000

        "set mouse=a

        set ruler
        set magic
        set mps+=<:> " this is great for C++ template meta-programming
        
        set wildignore+=*/.git/*,*/.hg/*,*/.svn/* " Linux/MacOSX
        set wildignore+=*.o,*.so,*.ko,*.bak
        
        set nowrap
        set guioptions=acm

        set foldmethod=syntax
        set virtualedit=all

        set stl=%f\ %m\ %r\ Line:\ %l/%L[%p%%]\ Col:\ %c\ Buf:\ #%n\ [%b][0x%B]

        set laststatus=2
        
        set updatetime=100
        
        set clipboard=unnamed
        set viminfo='10,<10000,:100,%,s1000,n~/.viminfo

        set spell

        set grepprg=cgrep

        " set ignorecase 
        " set smartcase  
        " set infercase

        set path+=/usr/include
        set path+=/usr/include/c++/4.9

        " default tab and stuff
        "
        set shiftwidth=4 
        set tabstop=4 
        set autoindent 
        set copyindent
        set smartindent 
        set smarttab

        " set t_Co=256

        set timeoutlen=1000 ttimeoutlen=50

        let g:airline_theme='molokai'

        if has("gui_running")
                set guifont=Terminus\ 10
                " colorscheme github
                colorscheme default
        else
                " colorscheme github
                colorscheme default
        endif

        set diffopt=filler,iwhite,context:10
" }
  

" plugin config {
        
        " this to avoid spurious highlight with c++11 lambdas 
        
        let c_no_curly_error = 1

        let Tlist_Use_Right_Window  = 1

        let g:load_doxygen_syntax   = 1


        """ tagbar
        
        let g:tagbar_width = 30
        
        """ clang completion...
        
        let g:clang_complete_auto   = 0
        let g:clang_complete_copen  = 1
        let g:clang_user_options    = '-std=c++11'

        """ you complete me...
        
        let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'
        let g:ycm_collect_identifiers_from_tags_files=1
        let g:ycm_confirm_extra_conf = 0

        """ my C/++ ctags options...
        
        let g:my_ctags_options = [ '--sort=foldcase', '--languages=C,C++', '--c++-kinds=+plx', '--fields=+liaS', '--extra=+q', '-I __attribute__+' ]

        """ ctrl+p
        
        let g:ctrlp_map = ''
        let g:ctrlp_dotfiles = 0

        """ powerline
        
        set encoding=utf-8
        let g:Powerline_symbols = 'fancy'
       
        runtime! ftplugin/man.vim
        runtime! ftplugin/gzip.vim
        runtime! ftplugin/taglist.vim 

        """ syntastic: C++/Haskell
        
        let g:syntastic_cpp_compiler = 'clang++'
        let g:syntastic_cpp_compiler_options = ' -std=c++11 -stdlib=libc++'
        let g:syntastic_haskell_hdevtools_args = '-g-isrc -g-Wall -g-cpp'

"}


" automatic {

if has("autocmd")

        let g:c_syntax_for_h = 1

        autocmd BufNewFile,BufRead *.c   set filetype=c   
        autocmd BufNewFile,BufRead *.h   set filetype=c   
        autocmd BufNewFile,BufRead *.cpp set filetype=cpp  
        autocmd BufNewFile,BufRead *.hpp set filetype=cpp  
        autocmd BufNewFile,BufRead *.hsc set filetype=haskell

        " save time-consuming foldmethod=syntax while in insert mode... 
        
        autocmd InsertEnter * if !exists('w:last_fdm') | let w:last_fdm=&foldmethod | setlocal foldmethod=manual | endif
        autocmd InsertLeave,WinLeave * if exists('w:last_fdm') | let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif

        " disable syntax on very huge files...
        
        autocmd BufReadPre *  if getfsize(expand('<afile>')) > 100000 | syntax off | endif
        autocmd BufEnter * set tags=~/.vim/system-tags,./tags,../tags,tags,TAGS

        autocmd QuickFixCmdPost [^l]* nested cwindow
        autocmd QuickFixCmdPost    l* nested lwindow

        autocmd FileType text setlocal textwidth=118
        
        " clear trailing white-spaces...
        " 
        autocmd FileType cpp,c,haskell,make autocmd BufWritePre <buffer> :%s/\s\+$//e

        autocmd FileType make set noexpandtab
        autocmd FileType make set shiftwidth=8
        
        autocmd BufWinEnter * call ResCur()

        autocmd FileType haskell call SetupHaskell()
        autocmd FileType cpp     call SetupCpp()
        autocmd FileType c       call SetupKernel()
endif

" }

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" functions {

if !exists(":DiffOrig")
        command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
        \ | wincmd p | diffthis
endif

function! ResCur()
        if line("'\"") <= line("$")
                norm! g`"
                return 1
        endif
endfunction

" eat a char

function Eatchar(pat)
        let c = nr2char(getchar(0))
        return (c =~ a:pat) ? '' : c
endfunc

" ctags functions 

function! UpdateCppTags()
        exec ":silent !echo Updating ctags..."
        exec ":silent !ctags -R " . join(g:my_ctags_options, ' ')    
        echohl StatusLine | echo "Ctags updated." | echohl None
endfunction

" hasktags functions 

function! UpdateHaskTags()
        exec ":silent !echo Updating hasktags..."
        exec ":silent !hasktags -c --ignore-close-implementation ."   
        echohl StatusLine | echo "Hasktags updated." | echohl None
endfunction

" http://vim.wikia.com/wiki/Toggle_to_open_or_close_the_quickfix_window
" toggles the quickfix window.

function! QFixToggle(forced)
  if exists("g:qfix_win") && a:forced == 0
    cclose
  else
    copen
  endif
endfunction


function! QuickFixFilenames()
    let buffer_numbers = {}
    for item in getqflist()
        let buffer_numbers[item['bufnr']] = bufname(item['bufnr'])
    endfor
    return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction


function! SearchWithSkip(pattern, flags, stopline, timeout, skip)
"
" Returns true if a match is found for {pattern}, but ignores matches
" where {skip} evaluates to false. This allows you to do nifty things
" like, say, only matching outside comments, only on odd-numbered lines,
" or whatever else you like.
"
" Mimics the built-in search() function, but adds a {skip} expression
" like that available in searchpair() and searchpairpos().
" (See the Vim help on search() for details of the other parameters.)
" 
    " Note the current position, so that if there are no unskipped
    " matches, the cursor can be restored to this location.
    "
    let l:matchpos = getpos('.')

    " Loop as long as {pattern} continues to be found.
    "
    while search(a:pattern, a:flags, a:stopline, a:timeout) > 0

        " If {skip} is true, ignore this match and continue searching.
        "
        if eval(a:skip)
            continue
        endif

        " If we get here, {pattern} was found and {skip} is false,
        " so this is a match we don't want to ignore. Update the
        " match position and stop searching.
        " 
        let l:matchpos = getpos('.')
        break

    endwhile

    " Jump to the position of the unskipped match, or to the original
    " position if there wasn't one.
    "
    call setpos('.', l:matchpos)

endfunction


function! SearchOutside(synName, pattern)
"
" Searches for the specified pattern, but skips matches that
" exist within the specified syntax region.
"
    call SearchWithSkip(a:pattern, '', '', '',
        \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "' . a:synName . '"' )

endfunction


function! SearchInside(synName, pattern)
"
" Searches for the specified pattern, but skips matches that don't
" exist within the specified syntax region.
"
    call SearchWithSkip(a:pattern, '', '', '',
        \ 'synIDattr(synID(line("."), col("."), 0), "name") !~? "' . a:synName . '"' )

endfunction

command! -nargs=+ -complete=command SearchOutside call SearchOutside(<f-args>)
command! -nargs=+ -complete=command SearchInside  call SearchInside(<f-args>)



" used to track the quickfix window

augroup QFixToggle
 autocmd!
 autocmd BufWinEnter quickfix let g:qfix_win = bufnr("$")
 autocmd BufWinLeave * if exists("g:qfix_win") && expand("<abuf>") == g:qfix_win | unlet! g:qfix_win | endif
augroup END

" }

" command {
 
    command! -nargs=* -complete=shellcmd R new | setlocal buftype=nofile bufhidden=hide noswapfile | R !<args>
    command! -bang -nargs=? QFix call QFixToggle(<bang>0)
    command! -nargs=0 -bar Qargs execute 'args' QuickFixFilenames()
" }


" language_options {

function SetupKernel()

        setlocal tabstop=8
        setlocal shiftwidth=8
        setlocal softtabstop=8
        setlocal textwidth=80
        setlocal noexpandtab

        setlocal cindent
        setlocal formatoptions=tcqlron
        setlocal cinoptions=:0,l1,t0,g0,(0

        cmap ;tf ?^{??(?,/^}/

        setlocal iskeyword=a-z,A-Z,48-57,_,'
        setlocal noexpandtab
        
        syn keyword cOperator  likely unlikely 
        syn keyword cType u8 u16 u32 u64 s8 s16 s32 s64

        highlight default link LinuxError ErrorMsg

        syn match LinuxError / \+\ze\t/     " spaces before tab
        syn match LinuxError /\s\+$/        " trailing whitespaces
        syn match LinuxError /\%121v.\+/    " virtual column 121 and more

        iab intmain int<CR>main(int argc, char *argv[])<CR>{<CR>return 0;<CR>}<CR><UP><UP><RIGHT>
        iab #i #include <><Left><C-R>=Eatchar('\s')<CR>
        iab #I #include ""<Left><C-R>=Eatchar('\s')<CR>
        iab #d #define 
        iab #p #pragma once

        iab __P __PRETTY_FUNCTION__
        iab __F __FUNCTION__
        iab __G __GXX_EXPERIMENTAL_CXX0X__

        nnoremap <F2>    :AssGen<CR>
        nnoremap <F11>   :AssClangRun <CR>
        nnoremap <S-F11> :AssGccRun <CR>
        nnoremap <S-F10> :AssIncludeThis<CR>
        
endfunction

function SetupCpp()
        
        cmap ;tf ?^{??(?,/^}/
        map <C-]> :exe "tj " . expand("<cword>") <CR>

        setlocal cinoptions={0}0:0=4l1g0p0t0i0+0(0u2W4
        setlocal shiftwidth=4 
        setlocal tabstop=4 
        setlocal iskeyword=a-z,A-Z,48-57,_,'
        setlocal cms=//%s

        " abbreviations...
        "
        iab intmain int<CR>main(int argc, char *argv[])<CR>{<CR>return 0;<CR>}<CR><UP><UP><RIGHT>
        iab #i #include <><Left><C-R>=Eatchar('\s')<CR>
        iab #I #include ""<Left><C-R>=Eatchar('\s')<CR>
        iab #d #define 
        iab #p #pragma once

        iab ns namespace<C-R>=Eatchar('\s')<CR>
        iab co std::cout<C-R>=Eatchar('\s')<CR>
        iab ce std::cerr<C-R>=Eatchar('\s')<CR>
        iab el std::endl<C-R>=Eatchar('\s')<CR>

        iab dt decltype()<Left><C-R>=Eatchar('\s')<CR>
        iab tn typename
        iab td typedef
        iab tp template <><Left><C-R>=Eatchar('\s')<CR>

        iab .\ []() {}<Left><Left><Left><Left><Left><Left><C-R>=Eatchar('\s')<CR>

        iab __P __PRETTY_FUNCTION__
        iab __F __FUNCTION__
        iab __G __GXX_EXPERIMENTAL_CXX0X__

        " C++ ass'instant: -> github.com/awgn/ass 
        
        nnoremap <F2>    :AssGen<CR>
        nnoremap <F4>    :call UpdateCppTags()<CR>
        nnoremap <F7>    :Make<CR>
        nnoremap <F11>   :AssClangRun <CR>
        nnoremap <S-F11> :AssGccRun <CR>
        nnoremap <S-F10> :AssIncludeThis<CR>
        
        " find the string in non-comment lines (C/C++)
        
        nnoremap <leader>f :/\v((\/\*\|\/\/\|^\s*\*[^/]).*)@<!
 
endfunction

function SetupHaskell()
        
        set makeprg=runhaskell

        setlocal shiftwidth=4 
        setlocal tabstop=4 
        setlocal iskeyword=a-z,A-Z,48-57,_,'
        setlocal omnifunc=necoghc#omnifunc
        
        " abbreviations...
        "
        iab HTH {-# LANGUAGE TemplateHaskell #-}
        iab HEQ {-# LANGUAGE ExistentialQuantification #-}
        iab HFI {-# LANGUAGE FlexibleInstances #-}
        iab HMP {-# LANGUAGE MultiParamTypeClasses #-}
        iab HVP {-# LANGUAGE ViewPatterns #-}
        iab HTS {-# LANGUAGE TupleSections #-}
        iab HBP {-# LANGUAGE BangPatterns #-}
        iab HOS {-# LANGUAGE OverloadedStrings #-}
        iab HOL {-# LANGUAGE OverloadedLists #-}
        iab HMH {-# LANGUAGE MagiHash #-}
        iab HGA {-# LANGUAGE GADTs #-}
        iab HGD {-# LANGUAGE GeneralizedNewtypeDeriving #-}

        " hdevtools...
        "
        nnoremap <buffer> <F1> :HdevtoolsType<CR>
        nnoremap <buffer> <silent> <F2> :HdevtoolsClear<CR>
        nnoremap <buffer> <silent> <F3> :HdevtoolsInfo<CR>
        nnoremap <F4> :call UpdateHaskTags()<CR>
 
        let g:hdevtools_options = '-g-isrc -g-Wall -g-cpp'

endfunction

" }

" mapping {
        
        " set mapleader
        
        let mapleader = ","
        
        " general keys...
        "
        nnoremap <F5>    :cprev<CR>
        nnoremap <F6>    :cnext<CR>
        nnoremap <F8>    :QFix<CR>
        nnoremap <F9>    :NERDTreeToggle<CR>
        nnoremap <F10>   :GundoToggle<CR>
        nnoremap <F12>   :TagbarToggle<CR>

        " leaders...
        "
        
        nnoremap <leader>p :CtrlP<CR>
        
        " search and stuff
        
        nnoremap / /\v
        nnoremap ? ?\v
        
        nnoremap <leader>/ /\<\><Left><Left>
        nnoremap <leader>? ?\<\><Left><Left>
        nnoremap <leader>c :/\(\<class\>\\|\<struct\>\)\s*[a-zA-Z_][a-zA-Z0-9_]*.*\_s*{<CR> 
        
        " eliminate ugly \r 
        
        nnoremap <leader>r :%s/\r//g<CR>

        " replace the world under cursor...
        
        nnoremap <leader>s :%s/\<<C-R><C-W>\>/
        
        " search the word under cursor...
       
        nnoremap <leader>g /\v<C-R><C-W><CR>:grep -r -w <C-R><C-W> 
        
        
        " prepare exact replace
        
        nnoremap <leader>S :%s/\<\>/<Left><Left><Left>

        " disable arrows
        
        map <up>    <nop>
        map <down>  <nop>
        map <left>  <nop>
        map <right> <nop>

        " disable annoying lowercase in visual mode.
       
        xmap u <nop>

        " leader d -> delete the current line, leaving the default register
        " untouched

        nnoremap <leader>d "_dd
        
        " D, delete a visual block using non default register
        
        vnoremap D "_d

        " expand,  %% in the relative directory of the current buffer
        
        cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'
 
        " hex editor...
        
        map <Leader>hon  :%!xxd<CR>
        map <Leader>hoff :%!xxd -r<CR>       
"}

