"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" my dot.vimrc config (don't try this at home!) Nicola
"

" general {

        call pathogen#infect()
        syntax enable

        filetype on
        filetype plugin on
        filetype indent on

        set nocompatible        	

        set backspace=indent,eol,start 
        
        set completeopt=menu,longest
        set complete=.,w,b,t,i

        set nofoldenable
        set novisualbell                
        set hidden
        set lazyredraw

        set wrapscan
        set ch=2
        set synmaxcol=1024
        set cpoptions+=$

        set expandtab
        set foldlevel=0
        set autowrite

        set hlsearch
        set incsearch

        set showcmd
        set showmode
        set showfulltag

        set wildmenu
        set pastetoggle=<F12>

        set history=1000
        set undolevels=1000

        "set mouse=a

        set ruler
        set magic
        set mps+=<:> " this is great for C++ template metaprogramming
        set wildignore+=*.o,*.so,*.ko,*.bak
        set nowrap
        set guioptions=acm

        set foldmethod=syntax
        set virtualedit=all
        set stl=%f\ %m\ %r\ Line:\ %l/%L[%p%%]\ Col:\ %c\ Buf:\ #%n\ [%b][0x%B]

        set laststatus=2
        set updatetime=100
        set clipboard=unnamed
        set viminfo='10,<10000,:100,%,s1000,n~/.viminfo

        set nospell

        set grepprg=cgrep

        set ignorecase
        set infercase
        set smartcase

        set path+=/usr/include
        set path+=/usr/include/c++/4.7

        " default tab and stuff
        "
        set shiftwidth=4 
        set tabstop=4 
        set autoindent 
        set copyindent
        set smartindent 
        set smarttab

        set t_Co=256

        if has("gui_running")
                set guifont=Terminus\ 10
                " colorscheme github
                " colorscheme mustang
                " set background=dark
                " colorscheme solarized
                " colorscheme jellybeans
                colorscheme default
        else
                " colorscheme github
                " colorscheme mustang
                " let g:solarized_termcolors=256
                " set background=dark
                " colorscheme solarized
                " colorscheme gummybears
                " colorscheme jellybeans
                colorscheme default
        endif

        set diffopt=filler,iwhite,context:10
"}


" global {
        
        " this to avoid spurious highlight with c++11 lambdas 
        let c_no_curly_error=1

        let Tlist_Use_Right_Window = 1

        let g:load_doxygen_syntax = 1

        let g:clang_complete_auto =  0
        let g:clang_complete_copen = 1
        let g:clang_user_options = '-std=c++11'

        let g:my_ctags_options    = [ '--sort=foldcase', '--languages=C,C++', '--c++-kinds=+plx', '--fields=+iaS', '--extra=+q', '-I __attribute__+' ]
        let g:ctrlp_map = ''
        set encoding=utf-8
        let g:Powerline_symbols = 'fancy'
        
        let g:haddock_browser="/usr/bin/w3m"
" }

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" plugins {

        runtime! ftplugin/man.vim
        runtime! ftplugin/gzip.vim
        runtime! ftplugin/taglist.vim 
"}

" automatic {

if has("autocmd")

        autocmd BufNewFile,BufRead *.cpp set syntax=cpp
        
        " save time-consuming foldmethod=syntax while in insert mode... (fast
        " paste!)
        "
        autocmd InsertEnter * if !exists('w:last_fdm') | let w:last_fdm=&foldmethod | setlocal foldmethod=manual | endif
        autocmd InsertLeave,WinLeave * if exists('w:last_fdm') | let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif

        " disable syntax on very huge files...
        "
        autocmd BufReadPre *  if getfsize(expand('<afile>')) > 1000000 | syntax off | endif

        autocmd BufEnter * set tags=~/.vim/system-tags,./tags,../tags,tags,TAGS
        autocmd BufEnter *.hs compiler ghc

        autocmd QuickFixCmdPost [^l]* nested cwindow
        autocmd QuickFixCmdPost    l* nested lwindow

        autocmd FileType text setlocal textwidth=118

        autocmd FileType cpp cmap ;tf ?^{??(?,/^}/
        autocmd FileType cpp map <C-]> :exe "tj " . expand("<cword>") <CR>
        autocmd FileType cpp set cinoptions={0}0:0=4l1g0p0t0i0+0(0u2W4
        autocmd FileType cpp set shiftwidth=4 
        autocmd FileType cpp set tabstop=4 
        autocmd FileType cpp set iskeyword=a-z,A-Z,48-57,_,'

        autocmd FileType c cmap ;tf ?^{??(?,/^}/
        autocmd FileType c set cinoptions=:0,l1,t0,g0
        autocmd FileType c set shiftwidth=8 
        autocmd FileType c set tabstop=8 
        autocmd FileType c set iskeyword=a-z,A-Z,48-57,_,'
        autocmd FileType c set formatoptions=tcqlron
        autocmd FileType c set noexpandtab

        autocmd FileType ruby  set shiftwidth=4 
        autocmd FileType ruby  set tabstop=4 
        autocmd FileType ruby  set iskeyword=a-z,A-Z,48-57,_

        autocmd FileType haskell set shiftwidth=4 
        autocmd FileType haskell set tabstop=4 
        autocmd FileType haskell set iskeyword=a-z,A-Z,48-57,_,'

        "autocmd FileType haskell nmap <C-c><C-l> :GhciRange<CR>
        "autocmd FileType haskell vmap <C-c><C-l> :GhciRange<CR>
        "autocmd FileType haskell nmap <C-c><C-f> :GhciFile<CR>
        "autocmd FileType haskell nmap <C-c><C-r> :GhciReload<CR>
        
        autocmd FileType make set noexpandtab
        autocmd FileType make set shiftwidth=8

        autocmd BufWinEnter * call ResCur()
endif

" }

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" functions {

if !exists(":DiffOrig")
        command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
        \ | wincmd p | diffthis
endif

function! ResCur()
        if line("'\"") <= line("$")
                norm! g`"
                return 1
        endif
endfunction


func Eatchar(pat)
        let c = nr2char(getchar(0))
        return (c =~ a:pat) ? '' : c
endfunc

" ctags functions 
"
function! UpdateTags()
        exec ":silent !echo Updating ctags..."
        exec ":silent !ctags -R " . join(g:my_ctags_options, ' ')    
        echohl StatusLine | echo "Ctags updated." | echohl None
endfunction


" http://vim.wikia.com/wiki/Toggle_to_open_or_close_the_quickfix_window
" toggles the quickfix window.

function! QFixToggle(forced)
  if exists("g:qfix_win") && a:forced == 0
    cclose
  else
    copen
  endif
endfunction


" used to track the quickfix window
augroup QFixToggle
 autocmd!
 autocmd BufWinEnter quickfix let g:qfix_win = bufnr("$")
 autocmd BufWinLeave * if exists("g:qfix_win") && expand("<abuf>") == g:qfix_win | unlet! g:qfix_win | endif
augroup END


" }

" command {
 
    command! -nargs=* -complete=shellcmd R new | setlocal buftype=nofile bufhidden=hide noswapfile | R !<args>
    command! -bang -nargs=? QFix call QFixToggle(<bang>0)

" }

" abbreviations {

        iab intmain int<CR>main(int argc, char *argv[])<CR>{<CR>return 0;<CR>}<CR>
        iab #i #include <><Left><C-R>=Eatchar('\s')<CR>
        iab #I #include ""<Left><C-R>=Eatchar('\s')<CR>
        iab #d #define 

        iab .b .begin()<C-R>=Eatchar('\s')<CR>
        iab .e .end()<C-R>=Eatchar('\s')<CR>
        iab ->b ->begin()<C-R>=Eatchar('\s')<CR>
        iab ->e ->end()<C-R>=Eatchar('\s')<CR>

        iab co std::cout<C-R>=Eatchar('\s')<CR>
        iab ce std::cerr<C-R>=Eatchar('\s')<CR>
        iab el std::endl<C-R>=Eatchar('\s')<CR>
        
        iab dt decltype()<Left><C-R>=Eatchar('\s')<CR>
        iab tn typename
        iab td typedef
        iab tp template <><Left><C-R>=Eatchar('\s')<CR>

        iab svec std::vector<><Left><C-R>=Eatchar('\s')<CR>
        iab smap std::map<><Left><C-R>=Eatchar('\s')<CR>
        iab sstr std::string<C-R>=Eatchar('\s')<CR>

        iab tre throw std::runtime_error("")<Left><Left><C-R>=Eatchar('\s')<CR>

        iab .\ []() {}<Left><Left><Left><Left><Left><Left><C-R>=Eatchar('\s')<CR>

        iab __P __PRETTY_FUNCTION__
        iab __F __FUNCTION__
        iab __G __GXX_EXPERIMENTAL_CXX0X__

        " haskell useful extensions..
        "
        iab Leq {-# LANGUAGE ExistentialQuantification #-}
        iab Lfi {-# LANGUAGE FlexibleInstances #-}
        iab Lmp {-# LANGUAGE MultiParamTypeClasses #-}
        iab Lvp {-# LANGUAGE ViewPatterns #-}

"}

" mapping {
        
        " C++ ass'instant: -> github.com/awgn/ass 
        "
        
        noremap <F1>    :AssGuard<CR>
        noremap <F2>    :AssGen<CR> 
        
        
        " search for the next class\struct declaration..
        "
        
        noremap <F3>    :/\(\<class\>\\|\<struct\>\)\s*[a-zA-Z_][a-zA-Z0-9_]*.*\_s*{<CR> 
        noremap <C-F3>  :?\(\<class\>\\|\<struct\>\)\s*[a-zA-Z_][a-zA-Z0-9_]*.*\_s*{<CR> 

        noremap <F6>    :cnext<CR>
        noremap <S-F6>  :cprev<CR>

        noremap <F7>    :make<CR>
        noremap <F8>    :QFix<CR>

        noremap <F9>    :call UpdateTags()<CR>

        noremap <F10>   :Bufferlist<CR>
        noremap <S-F10> :AssIncludeThis<CR>

        noremap <F11>   :AssClangRun <CR>
        noremap <S-F11> :AssGccRun <CR>

        noremap <F12>   :TagbarToggle<CR>
        noremap <S-F12> :NERDTreeToggle<CR>

        " set mapleader
        "
        let mapleader = ","

        noremap <leader>c :set syntax=cpp<CR>
        noremap <leader>r :%s/\r//g<CR>
        
        noremap <leader>/ /\<\><Left><Left>
        noremap <leader>? ?\<\><Left><Left>

        noremap <leader>s :%s/\<<C-R><C-W>\>/
        noremap <leader>S :%s/\<\>/<Left><Left><Left>

        noremap <leader>g :grep -r -w 
        noremap <leader>G :grep -r -w <C-R><C-W> 

        noremap <leader>f :CtrlP<CR>
        noremap <leader>b :CtrlPBuffer<CR>
        noremap <leader>r :CtrlPMRUFiles<CR>
        noremap <leader>p :CtrlPMixed<CR>

        "nnoremap <leader>ev :vsplit $MYVIMRC<cr>
        "nnoremap <leader>sv :source $MYVIMRC<cr>

        vmap Q gq
        nmap Q gqap

        map <up>    <nop>
        map <down>  <nop>
        map <left>  <nop>
        map <right> <nop>
"}

