"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" my dot.vimrc config (don't try this at home!) Nicola
"


" general {

        execute pathogen#infect()
        
        syntax enable

        filetype on
        filetype plugin on
        filetype indent on
       
        set nocompatible        	

        set rtp+=/root/.vim/bundle/powerline/powerline/bindings/vim

        set backspace=indent,eol,start 
        
        set completeopt=menu,longest
        set complete=.,w,b,t,i
        
        set shortmess+=at
 
        set nofoldenable
        set novisualbell                
        set hidden
        set lazyredraw

        set wrapscan
        set ch=2
        set synmaxcol=1024
        set cpoptions+=$

        set expandtab

        set foldlevel=0
        set autowrite

        set hlsearch
        set incsearch

        set showcmd
        set showmode
        set showfulltag

        set wildmenu
        set pastetoggle=<F12>

        set history=1000
        set undolevels=1000

        "set mouse=a

        set ruler
        set magic
        set mps+=<:> " this is great for C++ template meta-programming
        
        set wildignore+=*/.git/*,*/.hg/*,*/.svn/* " Linux/MacOSX
        set wildignore+=*.o,*.so,*.ko,*.bak
        
        set nowrap
        set guioptions=acm

        set foldmethod=syntax
        set virtualedit=all

        set stl=%f\ %m\ %r\ Line:\ %l/%L[%p%%]\ Col:\ %c\ Buf:\ #%n\ [%b][0x%B]

        set laststatus=2
        
        set updatetime=100
        
        set clipboard=unnamed
        set viminfo='10,<10000,:100,%,s1000,n~/.viminfo

        set spell

        set grepprg=cgrep

        " set ignorecase 
        " set smartcase  
        " set infercase

        set path+=/usr/include
        set path+=/usr/include/c++/4.8

        " default tab and stuff
        "
        set shiftwidth=4 
        set tabstop=4 
        set autoindent 
        set copyindent
        set smartindent 
        set smarttab

        set t_Co=256

        set timeoutlen=1000 ttimeoutlen=50

        if has("gui_running")
                set guifont=Terminus\ 10
                " colorscheme github
                colorscheme default
        else
                " colorscheme github
                colorscheme default
        endif

        set diffopt=filler,iwhite,context:10
"}
  

" plugin config {
        
        " this to avoid spurious highlight with c++11 lambdas 
        
        let c_no_curly_error=1

        let Tlist_Use_Right_Window  = 1

        let g:load_doxygen_syntax   = 1


        " tagbar
        
        let g:tagbar_width = 30
        
        " clang completion...
        
        let g:clang_complete_auto   = 0
        let g:clang_complete_copen  = 1
        let g:clang_user_options    = '-std=c++11'

        " you complete me...
        
        let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'
        let g:ycm_collect_identifiers_from_tags_files=1
        let g:ycm_confirm_extra_conf = 0

        " my ctags options...
        
        let g:my_ctags_options = [ '--sort=foldcase', '--languages=C,C++', '--c++-kinds=+plx', '--fields=+liaS', '--extra=+q', '-I __attribute__+' ]

        " ctrl+p
        
        let g:ctrlp_map = ''
        let g:ctrlp_dotfiles = 0

        " powerline
        
        set encoding=utf-8
        let g:Powerline_symbols = 'fancy'
       
        " ghc-mod
        
        let g:ghcmod_ghc_options = ['-Wall -cpp']

        runtime! ftplugin/man.vim
        runtime! ftplugin/gzip.vim
        runtime! ftplugin/taglist.vim 

        " devtools...
        
        let g:hdevtools_options = '-g-isrc -g-Wall -g-cpp'
"}


" automatic {

if has("autocmd")

        let g:c_syntax_for_h = 1

        autocmd BufNewFile,BufRead *.cpp set syntax=cpp
        autocmd BufNewFile,BufRead *.hsc set filetype=haskell

        " save time-consuming foldmethod=syntax while in insert mode... 
        
        autocmd InsertEnter * if !exists('w:last_fdm') | let w:last_fdm=&foldmethod | setlocal foldmethod=manual | endif
        autocmd InsertLeave,WinLeave * if exists('w:last_fdm') | let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif

        " disable syntax on very huge files...
        
        autocmd BufReadPre *  if getfsize(expand('<afile>')) > 1000000 | syntax off | endif

        autocmd BufEnter * set tags=~/.vim/system-tags,./tags,../tags,tags,TAGS

        autocmd QuickFixCmdPost [^l]* nested cwindow
        autocmd QuickFixCmdPost    l* nested lwindow

        autocmd FileType text setlocal textwidth=118
        
        " clear trailing white-spaces...
        " 
        autocmd FileType cpp,c,haskell,make autocmd BufWritePre <buffer> :%s/\s\+$//e

        autocmd FileType make set noexpandtab
        autocmd FileType make set shiftwidth=8

        autocmd BufWinEnter * call ResCur()
endif

" }

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" functions {

if !exists(":DiffOrig")
        command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
        \ | wincmd p | diffthis
endif

function! ResCur()
        if line("'\"") <= line("$")
                norm! g`"
                return 1
        endif
endfunction

" eat a char

function Eatchar(pat)
        let c = nr2char(getchar(0))
        return (c =~ a:pat) ? '' : c
endfunc

" ctags functions 

function! UpdateCppTags()
        exec ":silent !echo Updating ctags..."
        exec ":silent !ctags -R " . join(g:my_ctags_options, ' ')    
        echohl StatusLine | echo "Ctags updated." | echohl None
endfunction

" http://vim.wikia.com/wiki/Toggle_to_open_or_close_the_quickfix_window
" toggles the quickfix window.

function! QFixToggle(forced)
  if exists("g:qfix_win") && a:forced == 0
    cclose
  else
    copen
  endif
endfunction

function! QuickFixFilenames()
    let buffer_numbers = {}
    for item in getqflist()
        let buffer_numbers[item['bufnr']] = bufname(item['bufnr'])
    endfor
    return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction


" used to track the quickfix window

augroup QFixToggle
 autocmd!
 autocmd BufWinEnter quickfix let g:qfix_win = bufnr("$")
 autocmd BufWinLeave * if exists("g:qfix_win") && expand("<abuf>") == g:qfix_win | unlet! g:qfix_win | endif
augroup END

" }

" command {
 
    command! -nargs=* -complete=shellcmd R new | setlocal buftype=nofile bufhidden=hide noswapfile | R !<args>
    command! -bang -nargs=? QFix call QFixToggle(<bang>0)
    command! -nargs=0 -bar Qargs execute 'args' QuickFixFilenames()
    command! UpdateTags call UpdateCppTags()
" }


" language_options {

function CLangOptions()
        
        cmap ;tf ?^{??(?,/^}/

        setlocal cinoptions=:0,l1,t0,g0
        setlocal shiftwidth=8 
        setlocal tabstop=8 
        setlocal iskeyword=a-z,A-Z,48-57,_,'
        setlocal formatoptions=tcqlron
        setlocal noexpandtab
        
        syn keyword cOperator  likely unlikely 
        syn keyword cType u8 u16 u32 u64 s8 s16 s32 s64

        iab __P __PRETTY_FUNCTION__
        iab __F __FUNCTION__
        iab __G __GXX_EXPERIMENTAL_CXX0X__

        noremap <F3>    :AssGuard<CR>
        
endfunction

function CppLangOptions()
        
        cmap ;tf ?^{??(?,/^}/
        map <C-]> :exe "tj " . expand("<cword>") <CR>

        setlocal cinoptions={0}0:0=4l1g0p0t0i0+0(0u2W4
        setlocal shiftwidth=4 
        setlocal tabstop=4 
        setlocal iskeyword=a-z,A-Z,48-57,_,'
        setlocal cms=//%s

        " abbreviations...
        "
        iab intmain int<CR>main(int argc, char *argv[])<CR>{<CR>return 0;<CR>}<CR><UP><UP><RIGHT>
        iab #i #include <><Left><C-R>=Eatchar('\s')<CR>
        iab #I #include ""<Left><C-R>=Eatchar('\s')<CR>
        iab #d #define 
        iab #p #pragma once

        iab .b .begin()<C-R>=Eatchar('\s')<CR>
        iab .e .end()<C-R>=Eatchar('\s')<CR>
        iab ->b ->begin()<C-R>=Eatchar('\s')<CR>
        iab ->e ->end()<C-R>=Eatchar('\s')<CR>

        iab co std::cout<C-R>=Eatchar('\s')<CR>
        iab ce std::cerr<C-R>=Eatchar('\s')<CR>
        iab el std::endl<C-R>=Eatchar('\s')<CR>

        iab dt decltype()<Left><C-R>=Eatchar('\s')<CR>
        iab tn typename
        iab td typedef
        iab tp template <><Left><C-R>=Eatchar('\s')<CR>

        iab .\ []() {}<Left><Left><Left><Left><Left><Left><C-R>=Eatchar('\s')<CR>

        iab __P __PRETTY_FUNCTION__
        iab __F __FUNCTION__
        iab __G __GXX_EXPERIMENTAL_CXX0X__

        " C++ ass'instant: -> github.com/awgn/ass 
        
        noremap <F2>    :AssGen<CR>
        noremap <F3>    :AssGuard<CR>
        noremap <F11>   :AssClangRun <CR>
        noremap <S-F11> :AssGccRun <CR>
        noremap <S-F10> :AssIncludeThis<CR>
        
        " find the string in non-comment lines (C/C++)
        
        noremap <leader>f :/\v((\/\*\|\/\/\|^\s*\*[^/]).*)@<!
 
endfunction

function HaskellLangOptions()
        
        setlocal shiftwidth=4 
        setlocal tabstop=4 
        setlocal iskeyword=a-z,A-Z,48-57,_,'
        setlocal omnifunc=necoghc#omnifunc
        
        " abbreviations...
        "
        
        iab LTH {-# LANGUAGE TemplateHaskell #-}
        iab LEQ {-# LANGUAGE ExistentialQuantification #-}
        iab LFI {-# LANGUAGE FlexibleInstances #-}
        iab LMP {-# LANGUAGE MultiParamTypeClasses #-}
        iab LVP {-# LANGUAGE ViewPatterns #-}
        iab LTS {-# LANGUAGE TupleSections #-}
        iab LBP {-# LANGUAGE BangPatterns #-}
        iab LOS {-# LANGUAGE OverloadedStrings #-}
        iab LMH {-# LANGUAGE MagiHash #-}
        iab LGA {-# LANGUAGE GADTs #-}

        " ghc-mod
        
        noremap <leader>t :GhcModType<CR>
        noremap <leader><leader>t :GhcModTypeClear<CR>

        " hdevtools...
       "
        nnoremap <buffer> <F1> :HdevtoolsType<CR>
        nnoremap <buffer> <silent> <F2> :HdevtoolsClear<CR>

endfunction

" }

" mapping {
        
        " set mapleader
        
        let mapleader = ","
        
        " general keys...
        "
        noremap <F5>    :UpdateTags<CR>
        noremap <F6>    :cnext<CR>

        noremap <F7>    :Make<CR>
        noremap <F8>    :QFix<CR>
        noremap <F9>    :NERDTreeToggle<CR>
        noremap <F10>   :GundoToggle<CR>
        noremap <F12>   :TagbarToggle<CR>

        " leaders...
        "
        
        noremap <leader>c :set syntax=cpp<CR>
        
        " search and stuff
        
        noremap / /\v
        noremap ? ?\v
        
        noremap <leader>/ /\<\><Left><Left>
        noremap <leader>? ?\<\><Left><Left>
        noremap <leader>c :/\(\<class\>\\|\<struct\>\)\s*[a-zA-Z_][a-zA-Z0-9_]*.*\_s*{<CR> 
        
        " eliminate ugly \r 
        
        noremap <leader>r :%s/\r//g<CR>

        " replace the world under cursor...
        
        noremap <leader>s :%s/\<<C-R><C-W>\>/
        
        " prepare exact replace
        
        noremap <leader>S :%s/\<\>/<Left><Left><Left>

        noremap <leader>g :grep -r -w <C-R><C-W> 

        noremap <leader>u :Unite buffer file_rec<CR>

        " disable arrows
        
        map <up>    <nop>
        map <down>  <nop>
        map <left>  <nop>
        map <right> <nop>
       
        " leader d -> delete the current line, leaving the default register
        " untouched

        noremap <leader>d "_dd
        
        " D, delete a visual block using non default register
        
        vnoremap D "_d

        " expand,  %% in the relative directory of the current buffer
        
        cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'
 
        " hex editor...
        
        map <Leader>hon  :%!xxd<CR>
        map <Leader>hoff :%!xxd -r<CR>       
"}


autocmd FileType c       call CLangOptions()
autocmd FileType cpp     call CppLangOptions()
autocmd FileType haskell call HaskellLangOptions()

